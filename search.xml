<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pako-demo]]></title>
    <url>%2F2019%2F09%2F03%2Fjs-pako-demo%2F</url>
    <content type="text"><![CDATA[本次code demo展示了在前端如何使用pako进行数据压缩以及解压缩 关键字 Code Repository zip js pako 12345678910111213141516171819202122232425262728293031323334353637383940414243import pako from 'pako'// 压缩export const zip = (str) =&gt; &#123; let binaryString = pako.gzip(encodeURIComponent(str), &#123; to: 'string' &#125;) return btoa(binaryString)&#125;// 解压缩export const unzip = (sourceDate) =&gt; &#123; let strData = atob(sourceDate) // Convert binary string to character-number array let charData = strData.split('').map(function (x) &#123; return x.charCodeAt(0) &#125;) // Turn number array into byte-array let binData = new Uint8Array(charData) // // unzip let data = pako.inflate(binData) // Convert gunzipped byteArray back to ascii string: // 使用handleCodePoints防止堆栈溢出，原理未知，参考：https://www.jianshu.com/p/0d5791718b52 // strData = String.fromCharCode.apply(null, new Uint16Array(data)) strData = handleCodePoints(data) return decodeURIComponent(strData)&#125;function handleCodePoints (array) &#123; let CHUNK_SIZE = 0x8000 // arbitrary number here, not too small, not too big let index = 0 let length = array.length let result = '' let slice let arr = [] for (let i = 0, _i = array.length; i &lt; _i; i++) &#123; arr[i] = array[i] &#125; while (index &lt; length) &#123; slice = arr.slice(index, Math.min(index + CHUNK_SIZE, length)) // `Math.min` is not really necessary here I think result += String.fromCharCode.apply(null, slice) index += CHUNK_SIZE &#125; return result&#125; 总结:对于内容太多的解压缩会出现堆栈溢出的情况，所以需要用handleCodePoints去处理一下，详细情况请参阅https://www.jianshu.com/p/0d5791718b52 以下摘录部分原文：通过一般方式，可以正确解析数据，但是当数据量过大时，pako会报错误Maximumcallstacksizeexceeded;所以需要handleCodePoints方式处理，即将所有数据进行循环分块解析]]></content>
      <categories>
        <category>Code Repository</category>
      </categories>
      <tags>
        <tag>Code Repository</tag>
        <tag>js</tag>
        <tag>zip</tag>
        <tag>pako</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js复制内容到剪切板]]></title>
    <url>%2F2019%2F09%2F02%2Fjs-clipboard-copy%2F</url>
    <content type="text"><![CDATA[关键字 Code Repository js clipboard 1234567891011121314execCoy(text) &#123; const input = document.createElement('INPUT'); input.style.opacity = 0; input.style.position = 'absolute'; input.style.left = '-100000px'; document.body.appendChild(input); input.value = text; input.select(); input.setSelectionRange(0, text.length); document.execCommand('copy'); document.body.removeChild(input); return true;&#125; 利用一个不可见input，将要复制的文本写入value，再执行setSelectionRange选中，然后执行document.execCommand(‘copy’)将value写入系统剪切板。]]></content>
      <categories>
        <category>Code Repository</category>
      </categories>
      <tags>
        <tag>Code Repository</tag>
        <tag>js</tag>
        <tag>clipboard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new postdfsdsafdsasadfdsaf1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
